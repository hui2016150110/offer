

#### 二维数组中的查找

```kotlin
/**
     * 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，
     * 每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，
     * 输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
     *
     * 例如输入
     * [[1,   4,  7, 11, 15],
     * [2,   5,  8, 12, 19],
     * [3,   6,  9, 16, 22],
     * [10, 13, 14, 17, 24],
     * [18, 21, 23, 26, 30]]
     *
     * 5
     *
     * 返回true
     *
     */
```

解法一：通过暴力法——遍历整一个数组。这样做肯定是可以满足的，但是这样做得时间复杂度就是O(n*m)级别的了。



解法二：我们不妨观察以下这个数组的特征，从上到下是增加的，从左到右也是增加的。如果从第一个开始遍历，那么我们没有方法决定是往哪一个方向走。就是说，我们无法是决定往下去走还是往右走。换句话说，只要我们能够找到一个起点，通过这个起点的值和目标值的对比，我们每一次能够知道下一步是往能一个方向去走，就能很快找到我们的目标值了。

现在假设一个这是一个m行，n列的二维数组。很明显坐标为（0,0）的起点不符合我们的要求。坐标为（m-1,n-1）的坐标也不符合我们的要求。还有两个特殊的点，坐标为（0，n-1）的点（点a）和坐标为（m-1,0）的点（点b）两个点。如果从a点设为起点，那么我们能确定每一次走哪一个方向吗？答案是能的。如图

![image-20210714234117233](E:\md\剑指offer\二维数组中的查找.assets\image-20210714234117233.png)

通过图片可以看出来，从点（m-1,0），如果b点的数值大于目标值，那么这时候我们就应该往上走，如果如果b点的数值小于目标值，那么这时候我们就应该往右走。如果点b等于目标值就找到目标值，返回true。同理从点b开始也是一样的道理。**这一题注意点就是判空还有数组的边界。**

```kotlin
fun findNumberIn2DArray(matrix: Array<IntArray>, target: Int): Boolean {
        if (matrix.isEmpty() || matrix[0].isEmpty()) {
            return false
        }
        val row = matrix.size
        val col = matrix[0].size
        var curRow = row-1
        var curCol = 0
        while (curRow>=0&&curCol<=col-1){
            var curValue = matrix[curRow][curCol]
            if(curValue==target){
                return true
            }else if (curValue<target){
                curCol++
            }else{
                curRow--
            }

        }
        return false
    }
```

